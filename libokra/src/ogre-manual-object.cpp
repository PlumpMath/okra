// ogre-manual-object.cpp
//
// This file has been generated by the Okra Bindings Generator.
// You should not edit this file unless you know what you're doing.
// Any changes you've made directly to this file will not be retained
// when a new instance of this file is generated.
//
// author: Erik Winkels (aerique@xs4all.nl)
//
// See the LICENSE file in the Okra root directory for more info.
//
// This file was generated on: 2009-10-19 17:50:09.

#include "handwritten/okra.h"


// Prototypes

extern "C"
{
    void ogre_manual_object_clear (ManualObject*);
    void ogre_manual_object_estimate_vertex_count (ManualObject*, size_t);
    void ogre_manual_object_estimate_index_count (ManualObject*, size_t);
    void ogre_manual_object_begin (ManualObject*, const char*, RenderOperation::OperationType);
    void ogre_manual_object_set_dynamic (ManualObject*, bool);
    bool ogre_manual_object_get_dynamic (ManualObject*);
    void ogre_manual_object_begin_update (ManualObject*, size_t);
    void ogre_manual_object_position_vector3 (ManualObject*, const okraArray3);
    void ogre_manual_object_position_real_real_real (ManualObject*, Real, Real, Real);
    void ogre_manual_object_normal_vector3 (ManualObject*, const okraArray3);
    void ogre_manual_object_normal_real_real_real (ManualObject*, Real, Real, Real);
    void ogre_manual_object_texture_coord_real (ManualObject*, Real);
    void ogre_manual_object_texture_coord_real_real (ManualObject*, Real, Real);
    void ogre_manual_object_texture_coord_real_real_real (ManualObject*, Real, Real, Real);
    void ogre_manual_object_texture_coord_real_real_real_real (ManualObject*, Real, Real, Real, Real);
    void ogre_manual_object_texture_coord_vector2 (ManualObject*, const Vector2&);
    void ogre_manual_object_texture_coord_vector3 (ManualObject*, const okraArray3);
    void ogre_manual_object_texture_coord_vector4 (ManualObject*, const Vector4&);
    void ogre_manual_object_colour_colourvalue (ManualObject*, const okraArray4);
    void ogre_manual_object_colour_real_real_real_real (ManualObject*, Real, Real, Real, Real);
    void ogre_manual_object_index (ManualObject*, unsigned int);
    void ogre_manual_object_triangle (ManualObject*, unsigned int, unsigned int, unsigned int);
    void ogre_manual_object_quad (ManualObject*, unsigned int, unsigned int, unsigned int, unsigned int);
    ManualObject::ManualObjectSection* ogre_manual_object_end (ManualObject*);
    void ogre_manual_object_set_material_name_size_t_string (ManualObject*, size_t, const char*);
    Mesh* ogre_manual_object_convert_to_mesh (ManualObject*, const char*, const char*);
    void ogre_manual_object_set_use_identity_projection (ManualObject*, bool);
    bool ogre_manual_object_get_use_identity_projection (ManualObject*);
    void ogre_manual_object_set_use_identity_view (ManualObject*, bool);
    bool ogre_manual_object_get_use_identity_view (ManualObject*);
    void ogre_manual_object_set_bounding_box (ManualObject*, const okraArray6);
    ManualObject::ManualObjectSection* ogre_manual_object_get_section (ManualObject*, unsigned int);
    unsigned int ogre_manual_object_get_num_sections (ManualObject*);
    void ogre_manual_object_set_keep_declaration_order (ManualObject*, bool);
    bool ogre_manual_object_get_keep_declaration_order (ManualObject*);
    const char* ogre_manual_object_get_movable_type (ManualObject*);
    const AxisAlignedBox& ogre_manual_object_get_bounding_box (ManualObject*);
    Real ogre_manual_object_get_bounding_radius (ManualObject*);
    EdgeData* ogre_manual_object_get_edge_list (ManualObject*);
    bool ogre_manual_object_has_edge_list (ManualObject*);
    Entity::ShadowRenderableListIterator ogre_manual_object_get_shadow_volume_renderable_iterator (ManualObject*, ShadowTechnique, const Light*, HardwareIndexBufferSharedPtr*, bool, Real, unsigned long);
    void ogre_manual_object_visit_renderables (ManualObject*, Renderable::Visitor*, bool);
}


// Functions

// name: "clear"
// type: "void"
// args: "void"
//
void ogre_manual_object_clear (ManualObject* ogre_manual_object)
{
    ogre_manual_object->clear();
}

// name: "estimateVertexCount"
// type: "void"
// args: (("size_t" . "vcount"))
//
void ogre_manual_object_estimate_vertex_count (ManualObject* ogre_manual_object, size_t vcount)
{
    ogre_manual_object->estimateVertexCount(vcount);
}

// name: "estimateIndexCount"
// type: "void"
// args: (("size_t" . "icount"))
//
void ogre_manual_object_estimate_index_count (ManualObject* ogre_manual_object, size_t icount)
{
    ogre_manual_object->estimateIndexCount(icount);
}

// name: "begin"
// type: "void"
// args: (("const String&" . "materialName") ("RenderOperation::OperationType" . "opType"))
//
void ogre_manual_object_begin (ManualObject* ogre_manual_object, const char* materialName, RenderOperation::OperationType opType)
{
    ogre_manual_object->begin(materialName, opType);
}

// name: "setDynamic"
// type: "void"
// args: (("bool" . "dyn"))
//
void ogre_manual_object_set_dynamic (ManualObject* ogre_manual_object, bool dyn)
{
    ogre_manual_object->setDynamic(dyn);
}

// name: "getDynamic"
// type: "bool"
// args: "void"
//
bool ogre_manual_object_get_dynamic (ManualObject* ogre_manual_object)
{
    return ogre_manual_object->getDynamic();
}

// name: "beginUpdate"
// type: "void"
// args: (("size_t" . "sectionIndex"))
//
void ogre_manual_object_begin_update (ManualObject* ogre_manual_object, size_t sectionIndex)
{
    ogre_manual_object->beginUpdate(sectionIndex);
}

// name: "position"
// type: "void"
// args: (("const Vector3&" . "pos"))
//
void ogre_manual_object_position_vector3 (ManualObject* ogre_manual_object, const okraArray3 pos)
{
    Vector3 ogre_pos = Vector3(pos[0], pos[1], pos[2]);
    ogre_manual_object->position(ogre_pos);
}

// name: "position"
// type: "void"
// args: (("Real" . "x") ("Real" . "y") ("Real" . "z"))
//
void ogre_manual_object_position_real_real_real (ManualObject* ogre_manual_object, Real x, Real y, Real z)
{
    ogre_manual_object->position(x, y, z);
}

// name: "normal"
// type: "void"
// args: (("const Vector3&" . "norm"))
//
void ogre_manual_object_normal_vector3 (ManualObject* ogre_manual_object, const okraArray3 norm)
{
    Vector3 ogre_norm = Vector3(norm[0], norm[1], norm[2]);
    ogre_manual_object->normal(ogre_norm);
}

// name: "normal"
// type: "void"
// args: (("Real" . "x") ("Real" . "y") ("Real" . "z"))
//
void ogre_manual_object_normal_real_real_real (ManualObject* ogre_manual_object, Real x, Real y, Real z)
{
    ogre_manual_object->normal(x, y, z);
}

// name: "textureCoord"
// type: "void"
// args: (("Real" . "u"))
//
void ogre_manual_object_texture_coord_real (ManualObject* ogre_manual_object, Real u)
{
    ogre_manual_object->textureCoord(u);
}

// name: "textureCoord"
// type: "void"
// args: (("Real" . "u") ("Real" . "v"))
//
void ogre_manual_object_texture_coord_real_real (ManualObject* ogre_manual_object, Real u, Real v)
{
    ogre_manual_object->textureCoord(u, v);
}

// name: "textureCoord"
// type: "void"
// args: (("Real" . "u") ("Real" . "v") ("Real" . "w"))
//
void ogre_manual_object_texture_coord_real_real_real (ManualObject* ogre_manual_object, Real u, Real v, Real w)
{
    ogre_manual_object->textureCoord(u, v, w);
}

// name: "textureCoord"
// type: "void"
// args: (("Real" . "x") ("Real" . "y") ("Real" . "z") ("Real" . "w"))
//
void ogre_manual_object_texture_coord_real_real_real_real (ManualObject* ogre_manual_object, Real x, Real y, Real z, Real w)
{
    ogre_manual_object->textureCoord(x, y, z, w);
}

// name: "textureCoord"
// type: "void"
// args: (("const Vector2&" . "uv"))
//
void ogre_manual_object_texture_coord_vector2 (ManualObject* ogre_manual_object, const Vector2& uv)
{
    ogre_manual_object->textureCoord(uv);
}

// name: "textureCoord"
// type: "void"
// args: (("const Vector3&" . "uvw"))
//
void ogre_manual_object_texture_coord_vector3 (ManualObject* ogre_manual_object, const okraArray3 uvw)
{
    Vector3 ogre_uvw = Vector3(uvw[0], uvw[1], uvw[2]);
    ogre_manual_object->textureCoord(ogre_uvw);
}

// name: "textureCoord"
// type: "void"
// args: (("const Vector4&" . "xyzw"))
//
void ogre_manual_object_texture_coord_vector4 (ManualObject* ogre_manual_object, const Vector4& xyzw)
{
    ogre_manual_object->textureCoord(xyzw);
}

// name: "colour"
// type: "void"
// args: (("const ColourValue&" . "col"))
//
void ogre_manual_object_colour_colourvalue (ManualObject* ogre_manual_object, const okraArray4 col)
{
    ColourValue ogre_col = ColourValue(col[0], col[1], col[2], col[3]);
    ogre_manual_object->colour(ogre_col);
}

// name: "colour"
// type: "void"
// args: (("Real" . "r") ("Real" . "g") ("Real" . "b") ("Real" . "a"))
//
void ogre_manual_object_colour_real_real_real_real (ManualObject* ogre_manual_object, Real r, Real g, Real b, Real a)
{
    ogre_manual_object->colour(r, g, b, a);
}

// name: "index"
// type: "void"
// args: (("uint32" . "idx"))
//
void ogre_manual_object_index (ManualObject* ogre_manual_object, unsigned int idx)
{
    ogre_manual_object->index(idx);
}

// name: "triangle"
// type: "void"
// args: (("uint32" . "i1") ("uint32" . "i2") ("uint32" . "i3"))
//
void ogre_manual_object_triangle (ManualObject* ogre_manual_object, unsigned int i1, unsigned int i2, unsigned int i3)
{
    ogre_manual_object->triangle(i1, i2, i3);
}

// name: "quad"
// type: "void"
// args: (("uint32" . "i1") ("uint32" . "i2") ("uint32" . "i3") ("uint32" . "i4"))
//
void ogre_manual_object_quad (ManualObject* ogre_manual_object, unsigned int i1, unsigned int i2, unsigned int i3, unsigned int i4)
{
    ogre_manual_object->quad(i1, i2, i3, i4);
}

// name: "end"
// type: "ManualObjectSection*"
// args: "void"
//
ManualObject::ManualObjectSection* ogre_manual_object_end (ManualObject* ogre_manual_object)
{
    return ogre_manual_object->end();
}

// name: "setMaterialName"
// type: "void"
// args: (("size_t" . "subindex") ("const String&" . "name"))
//
void ogre_manual_object_set_material_name_size_t_string (ManualObject* ogre_manual_object, size_t subindex, const char* name)
{
    ogre_manual_object->setMaterialName(subindex, name);
}

// name: "convertToMesh"
// type: "MeshPtr"
// args: (("const String&" . "meshName") ("const String&" . "groupName"))
//
Mesh* ogre_manual_object_convert_to_mesh (ManualObject* ogre_manual_object, const char* meshName, const char* groupName)
{
    MeshPtr mesh_ptr = ogre_manual_object->convertToMesh(meshName, groupName);
    return mesh_ptr.getPointer();
}

// name: "setUseIdentityProjection"
// type: "void"
// args: (("bool" . "useIdentityProjection"))
//
void ogre_manual_object_set_use_identity_projection (ManualObject* ogre_manual_object, bool useIdentityProjection)
{
    ogre_manual_object->setUseIdentityProjection(useIdentityProjection);
}

// name: "getUseIdentityProjection"
// type: "bool"
// args: "void"
//
bool ogre_manual_object_get_use_identity_projection (ManualObject* ogre_manual_object)
{
    return ogre_manual_object->getUseIdentityProjection();
}

// name: "setUseIdentityView"
// type: "void"
// args: (("bool" . "useIdentityView"))
//
void ogre_manual_object_set_use_identity_view (ManualObject* ogre_manual_object, bool useIdentityView)
{
    ogre_manual_object->setUseIdentityView(useIdentityView);
}

// name: "getUseIdentityView"
// type: "bool"
// args: "void"
//
bool ogre_manual_object_get_use_identity_view (ManualObject* ogre_manual_object)
{
    return ogre_manual_object->getUseIdentityView();
}

// name: "setBoundingBox"
// type: "void"
// args: (("const AxisAlignedBox&" . "box"))
//
void ogre_manual_object_set_bounding_box (ManualObject* ogre_manual_object, const okraArray6 box)
{
    AxisAlignedBox ogre_box = AxisAlignedBox(box[0], box[1], box[2], box[3], box[4], box[5]);
    ogre_manual_object->setBoundingBox(ogre_box);
}

// name: "getSection"
// type: "ManualObjectSection*"
// args: (("unsigned int" . "index"))
//
ManualObject::ManualObjectSection* ogre_manual_object_get_section (ManualObject* ogre_manual_object, unsigned int index)
{
    return ogre_manual_object->getSection(index);
}

// name: "getNumSections"
// type: "unsigned int"
// args: "void"
//
unsigned int ogre_manual_object_get_num_sections (ManualObject* ogre_manual_object)
{
    return ogre_manual_object->getNumSections();
}

// name: "setKeepDeclarationOrder"
// type: "void"
// args: (("bool" . "keepOrder"))
//
void ogre_manual_object_set_keep_declaration_order (ManualObject* ogre_manual_object, bool keepOrder)
{
    ogre_manual_object->setKeepDeclarationOrder(keepOrder);
}

// name: "getKeepDeclarationOrder"
// type: "bool"
// args: "void"
//
bool ogre_manual_object_get_keep_declaration_order (ManualObject* ogre_manual_object)
{
    return ogre_manual_object->getKeepDeclarationOrder();
}

// name: "getMovableType"
// type: "const String&"
// args: "void"
//
const char* ogre_manual_object_get_movable_type (ManualObject* ogre_manual_object)
{
    return ogre_manual_object->getMovableType().c_str();
}

// name: "getBoundingBox"
// type: "const AxisAlignedBox&"
// args: "void"
//
const AxisAlignedBox& ogre_manual_object_get_bounding_box (ManualObject* ogre_manual_object)
{
    return ogre_manual_object->getBoundingBox();
}

// name: "getBoundingRadius"
// type: "Real"
// args: "void"
//
Real ogre_manual_object_get_bounding_radius (ManualObject* ogre_manual_object)
{
    return ogre_manual_object->getBoundingRadius();
}

// name: "getEdgeList"
// type: "EdgeData*"
// args: "void"
//
EdgeData* ogre_manual_object_get_edge_list (ManualObject* ogre_manual_object)
{
    return ogre_manual_object->getEdgeList();
}

// name: "hasEdgeList"
// type: "bool"
// args: "void"
//
bool ogre_manual_object_has_edge_list (ManualObject* ogre_manual_object)
{
    return ogre_manual_object->hasEdgeList();
}

// name: "getShadowVolumeRenderableIterator"
// type: "ShadowRenderableListIterator"
// args: (("ShadowTechnique" . "shadowTechnique") ("const Light*" . "light") ("HardwareIndexBufferSharedPtr*" . "indexBuffer") ("bool" . "extrudeVertices") ("Real" . "extrusionDist") ("unsigned long" . "flags"))
//
Entity::ShadowRenderableListIterator ogre_manual_object_get_shadow_volume_renderable_iterator (ManualObject* ogre_manual_object, ShadowTechnique shadowTechnique, const Light* light, HardwareIndexBufferSharedPtr* indexBuffer, bool extrudeVertices, Real extrusionDist, unsigned long flags)
{
    return ogre_manual_object->getShadowVolumeRenderableIterator(shadowTechnique, light, indexBuffer, extrudeVertices, extrusionDist, flags);
}

// name: "visitRenderables"
// type: "void"
// args: (("Renderable::Visitor*" . "visitor") ("bool" . "debugRenderables"))
//
void ogre_manual_object_visit_renderables (ManualObject* ogre_manual_object, Renderable::Visitor* visitor, bool debugRenderables)
{
    ogre_manual_object->visitRenderables(visitor, debugRenderables);
}


